enum BadgeStatus {
  Absent
  Requested
  Approved
  Challenged
  RequestRemoval
}

enum KlerosRequestType {
  Registration # Identifies a request to register an item to the registry.
  Clearing # Identifies a request to remove an item from the registry.
}

enum Controller {
  kleros
}

## - BADGE Model
type BadgeModel @entity {
  id: ID! # BadgeType id
  uri: String!
  controllerType: String!
  validFor: BigInt!
  creatorFee: BigInt!
  paused: Boolean!
  creator: User!
  badgesMintedAmount: BigInt!
  createdAt: BigInt!

  badgeModelKleros: BadgeModelKlerosMetaData @derivedFrom(field: "badgeModelId")
  mintedBadges: [Badge!]! @derivedFrom(field: "badgeModel")
}

type BadgeModelKlerosMetaData @entity {
  id: ID!
  badgeModelId: BadgeModel!
  registrationUri: String!
  removalUri: String!
  tcrList: Bytes!
  submissionBaseDeposit: BigInt!
  challengePeriodDuration: BigInt!
  #TODO: set governor, arbitrator, etc
}

## - BADGE

type Badge @entity {
  id: ID!
  badgeModel: BadgeModel!
  uri: String!
  account: User! # The receiver of the badge
  status: BadgeStatus!
  validFor: BigInt!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData @derivedFrom(field: "badge")
}

## Equivalent to Kleros LItem
type BadgeKlerosMetaData @entity {
  id: ID! # the same as ID as the BADGE
  badge: Badge!
  itemID: Bytes!
  reviewDueDate: BigInt! # The timestamp when the review period ends. if zero, it does not have review period
  # requests: [KlerosBadgeRequest!]!
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  requests: Request @derivedFrom(field: "badgeKlerosMetaData")
}

type KlerosBadgeIdToBadgeId @entity {
  id: ID! # itemID from kleros.
  badgeId: String! # badge id.
}

type EvidenceGroupIDToRequestIDToItemID @entity {
  id: ID!
  "Item submission ID, it can be a TCR random item or a badge submission request"
  request: String!
  itemID: String!
}

## - USER

type User @entity {
  id: ID!
  badges: [Badge!] @derivedFrom(field: "account") # TODO: check how to handle different types of badges
  mintedBadgesAmount: BigInt!
  # creator
  isCreator: Boolean!
  isVerified: Boolean!
  createdBadgeModels: [BadgeModel!] @derivedFrom(field: "creator")
  creatorUri: String
  createdBadgesModelAmount: BigInt!
}

## Kleros Entities, source: https://github.com/kleros/gtcr-subgraph/blob/master/schema.graphql

enum Ruling {
  "The arbitrator did not rule or refused to rule."
  None
  "The arbitrator ruled in favor of the requester."
  Accept
  "The arbitrator in favor of the challenger."
  Reject
}

type Evidence @entity {
  "<Request.id>-<evidence number>"
  id: ID!
  "The URI of the evidence file."
  URI: String!
  "When was this evidence posted"
  timestamp: BigInt!
}

## Equivalent to Kleros LRequest
type Request @entity {
  id: ID!
  type: KlerosRequestType!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData
  requestIndex: BigInt
  arbitrationParamsIndex: BigInt
  disputeID: BigInt
  requester: Bytes
  challenger: Bytes
  evidences: [Evidence!]
  "Number of evidences."
  numberOfEvidences: BigInt!
  "The time the request was resolved."
  resolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "True if the request was executed and/or any raised disputes were resolved."
  resolved: Boolean!
  "The hash of the transaction that solved this request."
  resolutionTx: Bytes
  "The outcome of the dispute, if any. Note that unsuccessful appeal fundings can invert the arbitrator ruling (so this may differ from the ruling given by the arbitrator)."
  disputeOutcome: Ruling!
}
