enum BadgeStatus {
  Absent
  Requested
  Approved
  Challenged
  RequestRemoval
}

enum KlerosRequestType {
  Registration # Identifies a request to register an item to the registry.
  Clearing # Identifies a request to remove an item from the registry.
}

enum Controller {
  kleros
}

## - BADGE Model
type BadgeModel @entity {
  id: ID!
  uri: String!
  controllerType: String!
  validFor: BigInt!
  creatorFee: BigInt!
  paused: Boolean!
  creator: User!
  badgesMintedAmount: BigInt!
  createdAt: BigInt!
  badgeModelKleros: BadgeModelKlerosMetaData
  contractAddress: Bytes!
  mintedBadges: [Badge!]! @derivedFrom(field: "badgeModel")
}

type BadgeModelKlerosMetaData @entity {
  id: ID!
  badgeModelId: BadgeModel!
  registrationUri: String!
  removalUri: String!
  tcrList: Bytes!
  submissionBaseDeposit: BigInt!
  challengePeriodDuration: BigInt!
  #TODO: set governor, arbitrator, etc
}

## - BADGE

type Badge @entity {
  id: ID!
  badgeModel: BadgeModel!
  uri: String!
  account: User! # The receiver of the badge
  status: BadgeStatus!
  validUntil: BigInt!
  createdAt: BigInt!
  createdTxHash: Bytes!
  badgeKlerosMetaData: BadgeKlerosMetaData @derivedFrom(field: "badge")
}

## Equivalent to Kleros LItem
type BadgeKlerosMetaData @entity {
  id: ID! # the same as ID as the BADGE
  badge: Badge!
  itemID: Bytes!
  reviewDueDate: BigInt! # The timestamp when the review period ends. if zero, it does not have review period
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  requests: [KlerosBadgeRequest!]! @derivedFrom(field: "badgeKlerosMetaData")
}

type _KlerosBadgeIdToBadgeId @entity {
  id: ID! # itemID from kleros.
  badgeId: String! # badge id.
}

type _EvidenceGroupIDItemID @entity {
  id: ID!
  "Item submission ID, it can be a TCR random item or a badge submission request"
  itemID: String!
}

type _ItemIDToEvidenceGroupIDToBadgeID @entity {
  "Item submission ID, it can be a TCR random item or a badge submission request"
  id: ID!
  evidenceGroupID: String!
  badgeID: String
}

## - USER

type User @entity {
  id: ID!
  badges: [Badge!] @derivedFrom(field: "account") # TODO: check how to handle different types of badges
  createdBadgeModels: [BadgeModel!] @derivedFrom(field: "creator")
  # creator
  isCreator: Boolean!
  isCurator: Boolean!
  isVerified: Boolean!
  creatorUri: String
  "User protocol statistics."
  statistics: UserStatistic!
}

## Kleros Entities, source: https://github.com/kleros/gtcr-subgraph/blob/master/schema.graphql

enum Ruling {
  "The arbitrator did not rule or refused to rule."
  None
  "The arbitrator ruled in favor of the requester."
  Accept
  "The arbitrator in favor of the challenger."
  Reject
}

type Evidence @entity {
  "<Request.id>-<evidence number>"
  id: ID!
  "The URI of the evidence file."
  uri: String!
  "When was this evidence posted"
  timestamp: BigInt!
  "Who has send the evidence"
  sender: Bytes!
  "The latest request when this evidence was submitted."
  request: KlerosBadgeRequest
}

## Equivalent to Kleros LRequest
type KlerosBadgeRequest @entity {
  id: ID!
  type: KlerosRequestType!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData
  requestIndex: BigInt
  arbitrationParamsIndex: BigInt
  disputeID: BigInt
  requester: Bytes
  challenger: Bytes
  "Evidence provided regarding this request (matching evidenceGroupID)."
  evidences: [Evidence!]! @derivedFrom(field: "request")
  "Number of evidences."
  numberOfEvidences: BigInt!
  "The time the request was resolved."
  resolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "True if the request was executed and/or any raised disputes were resolved."
  resolved: Boolean!
  "The hash of the transaction that solved this request."
  resolutionTx: Bytes
  "The outcome of the dispute, if any. Note that unsuccessful appeal fundings can invert the arbitrator ruling (so this may differ from the ruling given by the arbitrator)."
  disputeOutcome: Ruling!
  "The arbitrator's address."
  arbitrator: Bytes!
}

type ProtocolStatistic @entity {
  # If the same as the contractAddress
  id: ID!
  badgeModelsCreatedAmount: BigInt!
  badgesMintedAmount: BigInt!
  badgesChallengedAmount: BigInt! #
  # The amount of DIFFERENT users that owns at least one badge
  badgesOwnersAmount: BigInt!
  badgeCreatorsAmount: BigInt!
  badgeCuratorsAmount: BigInt!

  # Keep track of the users that made at least one curation
  badgeCurators: [Bytes!]! #
  # Keep track of the users that registered as creators
  badgeCreators: [Bytes!]!
}

type UserStatistic @entity {
  id: ID!
  user: User!

  # User statistics
  mintedBadgesAmount: BigInt!
  timeSinceLastChallengeReceived: BigInt!
  challengesReceivedAmount: BigInt!
  challengesReceivedLostAmount: BigInt!
  challengesReceivedWonAmount: BigInt!

  # Creator statistics
  createdBadgesModelAmount: BigInt!
  # Amount of BADGES created by this users MINTED by other users
  createdBadgesMintedAmount: BigInt!
  # Amount of different USERS that minted at least one of the badges of this creator
  usersMintedBadgesAmount: BigInt!
  # The ID of the badge created by this user which has the max amount of mints by others users
  createdBadgeIDMostPopular: BigInt!
  creatorRankingPosition: BigInt! # TODO implement in contract

  # Curator statistics
  challengesMadeAmount: BigInt!
  challengesMadeLostAmount: BigInt!
  challengesMadeWonAmount: BigInt!
  curatorRankingPosition: BigInt! # TODO implement in contract
}