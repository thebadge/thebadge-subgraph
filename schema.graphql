enum BadgeStatus {
  Absent
  Requested
  Approved
  Challenged
  RequestRemoval
}

enum KlerosRequestType {
  Registration # Identifies a request to register an item to the registry.
  Clearing # Identifies a request to remove an item from the registry.
}

enum Controller {
  kleros
}

## - BADGE Model
type BadgeModel @entity {
  id: ID! # BadgeType id
  uri: String!
  controllerType: String!
  validFor: BigInt!
  creatorFee: BigInt!
  paused: Boolean!
  creator: User!
  badgesMintedAmount: BigInt!
  createdAt: BigInt!

  badgeModelKleros: BadgeModelKlerosMetaData @derivedFrom(field: "badgeModelId")
  mintedBadges: [Badge!]! @derivedFrom(field: "badgeModel")
}

type BadgeModelKlerosMetaData @entity {
  id: ID!
  badgeModelId: BadgeModel!
  registrationUri: String!
  removalUri: String!
  tcrList: Bytes!
  submissionBaseDeposit: BigInt!
  challengePeriodDuration: BigInt!
  #TODO: set governor, arbitrator, etc
}

## - BADGE

type Badge @entity {
  id: ID!
  badgeModel: BadgeModel!
  uri: String!
  account: User! # The receiver of the badge
  status: BadgeStatus!
  validFor: BigInt!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData @derivedFrom(field: "badge")
}

## Equivalent to Kleros LItem
type BadgeKlerosMetaData @entity {
  id: ID! # the same as ID as the BADGE
  badge: Badge!
  itemID: Bytes!
  reviewDueDate: BigInt! # The timestamp when the review period ends. if zero, it does not have review period
  # requests: [KlerosBadgeRequest!]!
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  requests: KlerosBadgeRequest @derivedFrom(field: "badgeKlerosMetaData")
}

type KlerosBadgeIdToBadgeId @entity {
  id: ID! # itemID from kleros.
  badgeId: String! # badge id.
}

type KlerosBadgeEvidence @entity {
  "<Request.id>-<evidence number>"
  id: ID!
  "The URI of the evidence file."
  URI: String!
  "When was this evidence posted"
  timestamp: BigInt!
}

## Equivalent to Kleros LRequest
type KlerosBadgeRequest @entity {
  id: ID!
  type: KlerosRequestType!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData!
  requestIndex: BigInt!
  arbitrationParamsIndex: BigInt!
  disputeID: BigInt
  requester: Bytes
  challenger: Bytes
  evidences: [KlerosBadgeEvidence!]!
  "Number of evidences."
  numberOfEvidences: BigInt!
  "The time the request was resolved."
  resolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "True if the request was executed and/or any raised disputes were resolved."
  resolved: Boolean!
  "The hash of the transaction that solved this request."
  resolutionTx: Bytes
  "The outcome of the dispute, if any. Note that unsuccessful appeal fundings can invert the arbitrator ruling (so this may differ from the ruling given by the arbitrator)."
  disputeOutcome: Ruling!
}

## - USER

type User @entity {
  id: ID!
  badges: [Badge!] @derivedFrom(field: "account") # TODO: check how to handle different types of badges
  mintedBadgesAmount: BigInt!
  # creator
  isCreator: Boolean!
  isVerified: Boolean!
  createdBadgeModels: [BadgeModel!] @derivedFrom(field: "creator")
  creatorUri: String
  createdBadgesModelAmount: BigInt!
}

## Kleros Entities, source: https://github.com/kleros/gtcr-subgraph/blob/master/schema.graphql

enum Status {
  "The item is not registered on the TCR and there are no pending requests."
  Absent
  "The item is registered and there are no pending requests."
  Registered
  "The item is not registered on the TCR, but there is a pending registration request."
  RegistrationRequested
  "The item is registered on the TCR, but there is a pending removal request. These are sometimes also called removal requests."
  ClearingRequested
}

enum Ruling {
  "The arbitrator did not rule or refused to rule."
  None
  "The arbitrator ruled in favor of the requester."
  Accept
  "The arbitrator in favor of the challenger."
  Reject
}

type Arbitrator @entity {
  "The address of the arbitrator"
  id: ID!
}

type LRegistry @entity {
  "The registry address"
  id: ID!
  "The number of MetaEvidence event logs emitted."
  metaEvidenceCount: BigInt!
  "The items submitted to this list"
  items: [LItem!]! @derivedFrom(field: "registry")
  "The requests submitted to this list"
  requests: [LRequest!]! @derivedFrom(field: "registry")
  "The total number of items in absent state."
  numberOfAbsent: BigInt!
  "The total number of items in registered state."
  numberOfRegistered: BigInt!
  "The total number of items in the registration requested state."
  numberOfRegistrationRequested: BigInt!
  numberOfClearingRequested: BigInt!
  "The total number of items in the challenged registration state."
  numberOfChallengedRegistrations: BigInt!
  "The total number of items in the challenged removal state."
  numberOfChallengedClearing: BigInt!
}

type EvidenceGroupIDToLRequest @entity {
  "<EvidenceGroupID>@<contract address>"
  id: ID!
  "LRequest ID"
  request: LRequest!
}

type LItem @entity {
  "The id of the item in the subgraph entity. Format: <itemID>@<listaddress_lowercase>"
  id: ID!
  "The ID of the item in the registry. Also the keccak256 hash of the data."
  itemID: Bytes!
  "The data describing the item."
  data: String!
  "The parsed data describing the item."
  props: [ItemProp!]! @derivedFrom(field: "item")
  "First indexable value of the json file."
  key0: String
  "Second indexable value of the json file."
  key1: String
  "Third indexable value of the json file."
  key2: String
  "Fourth indexable value of the json file."
  key3: String
  "Fifth indexable value of the json file."
  key4: String
  "The item identifiers combined as a single string."
  keywords: String
  "The address of the mint transaction hash"
  mintTxHash: Bytes!
  "The current status of the item."
  status: Status!
  "List of status change requests made for the item in the form requests[requestID]."
  requests: [LRequest!]! @derivedFrom(field: "item")
  "The total number of requests for this item."
  numberOfRequests: BigInt!
  "The registry where this item was submitted."
  registry: LRegistry!
  "Time when the latest request was made."
  latestRequestSubmissionTime: BigInt!
  "The time the latest request was resolved."
  latestRequestResolutionTime: BigInt!
  "Whether the item is currently disputed."
  disputed: Boolean!
  "The account that made the latest request to the item."
  latestRequester: Bytes!
  "The account that challenged the latest request, if any."
  latestChallenger: Bytes!
}

type _Schema_
  @fulltext(
    name: "itemSearch"
    language: en
    algorithm: rank
    include: [{ entity: "LItem", fields: [{ name: "keywords" }] }]
  )

type ItemProp @entity {
  id: ID!
  type: String!
  label: String!
  description: String!
  isIdentifier: Boolean!
  value: String
  item: LItem!
}


